# Предварительная настройка. 

Sonarqube использует под капотом Elasticsearch и для корректной работы сервиса, необходимы указанные границы системных лимитов:
```
sysctl -w vm.max_map_count=524288
sysctl -w fs.file-max=131072
ulimit -n 131072
ulimit -u 8192
```

Подъем docker-compose, обязательно следите, чтобы команда выполнялась из-под рука.
```
sudo docker-compose -p jenkins up
```

Как только compose поднялся, в браузере можно переходить на localhost:8080 (если меняли порт в docker-compose, то указываете другой). 
При старте вас попросят ввести админский пароль, который можно посмотреть в логах докер-контейнера для jenkins
```
docker logs jenkins
```
Так же вы можете подсмотреть этот пароль в jenkins_home/secrets/initialAdminPassword

# Задание 

В этом задании мы будем моделировать 2 кейса, причем для реализации этих кейсов будем использовать 2 типа пайплайнов: pipeline и freestyle job.

## Первый кейс

Рассматриваем ситуацию, когда разработчик ведет разработку продукта в локальной ветке, добавляется функциональность некоторой новой фичи или
фикс бага. Разработчик хочет руками запустить пайплайн, который вытащит код с гитхаба, произведет сборку и прогонит юнит-тесты. При этом будет
возможность указать, с какой ветки нужно выкачивать код (в команде несколько разраотчиков, каждый работает в своей ветке, каждый хочет гонять
этот сценарий), какие юнит-тесты прогонять (новая функциональность или баг скорее всего затрагивает только часть приложения, не обязательно
гонять все юнит-тесты, которых может быть сотни).

Для решения этой задачи будет использоваться freestyle job.

Freestyle job настраивается в веб-интерфейсе самого jenkins. Сборка будет параметрической, добавим возможность включать/отключать прогон
юнит-тестов и авто-тестов

![](https://github.com/pavel-collab/SBT-DevOpsHT/blob/Lab04/Lab04/images/piplene_parameters_setting.png)

Кроме того, будем перед каждыйм прогоном чистить пространство, чтобы нам не мешали предыдущие артефакты сборки и выводить время срабатывания
команд в консоли

![](https://github.com/pavel-collab/SBT-DevOpsHT/blob/Lab04/Lab04/images/freestyle_pipleline_settings.png)

Freestyle pipeline создается путем настройки блоков с командами

![](https://github.com/pavel-collab/SBT-DevOpsHT/blob/Lab04/Lab04/images/freestyle_pipeline.png)

После настройки пайплайна будет доступна опция __Собрать с параметрами__

![](https://github.com/pavel-collab/SBT-DevOpsHT/blob/Lab04/Lab04/images/freestyle_pipeline_parameters.png)

## Второй кейс

Рассматриваем ситуацию, когда разработчик закончил работу в локальной ветке, убедился, что все собирается корректно, отрефакторил код, прогнал 
юнит-тесты, которые затрагивают его работу и делает push в основную релизную ветку. Как только в релизную ветку (develop или main или release) 
происходит пуш, сразу должен срабатывать триггер, запускающий пайплайн, который будет проверять код по всем фронтам: сборка, прогонка юнит-тестов и авто-тестов, формирование отчета о покрытии, полный фарш.

Для этой цели будем использовать pipeline и сценарии через jenkins-файлы.

Для запуска пайплайна будем использовать Jenkinsfile. Но Jenkinsfile с groovy кодом находится на гитхабе,  так что надо его оттуда вытащить
(как правило, Jenkinsfile находится в том же репозитории, что и сам проект, но в данном случае это не так исплючительно в образовательных целях).

Мы настраиваем выкачивание проекта с гитхаба: указываем url, ветку и путь к Jenkinsfile. Далее пайплайн начинает работать согласно groovy коду.

![](https://github.com/pavel-collab/SBT-DevOpsHT/blob/Lab04/Lab04/images/pipeline_settings.png)