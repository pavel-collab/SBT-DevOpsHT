# Предварительная настройка. 

Sonarqube использует под капотом Elasticsearch и для корректной работы сервиса, необходимы указанные границы системных лимитов:
```
sysctl -w vm.max_map_count=524288
sysctl -w fs.file-max=131072
ulimit -n 131072
ulimit -u 8192
```

Подъем docker-compose, обязательно следите, чтобы команда выполнялась из-под рука.
```
sudo docker-compose -p jenkins up
```

Как только compose поднялся, в браузере можно переходить на localhost:8080 (если меняли порт в docker-compose, то указываете другой). 
При старте вас попросят ввести админский пароль, который можно посмотреть в логах докер-контейнера для jenkins
```
docker logs jenkins
```
Так же вы можете подсмотреть этот пароль в jenkins_home/secrets/initialAdminPassword

После того, как вы первый раз попадете на заглавную траницу jenkins и авторизуетесь под админом вам нужно будет выполнить установку плагинов.
Можно выбрать установку стандартного набора плагинов (рекомендуется в этой работе), а можно самостоятельно составить список плагинов,
необходимых для работы. Установка плагинов может занять некоторое время, проследите, чтобы все плагины установились корректно. 

После установки плагинов будет предложен создать учетную запись, поменять админский пароль и станет доступен функционал работы с джобами.

# Задание 

В этом задании мы будем моделировать 2 кейса, причем для реализации этих кейсов будем использовать 2 типа пайплайнов: pipeline и freestyle job.

## Первый кейс

Рассматриваем ситуацию, когда разработчик ведет разработку продукта в локальной ветке, добавляется функциональность некоторой новой фичи или
фикс бага. Разработчик хочет руками запустить пайплайн, который вытащит код с гитхаба, произведет сборку и прогонит юнит-тесты. При этом будет
возможность указать, с какой ветки нужно выкачивать код (в команде несколько разраотчиков, каждый работает в своей ветке, каждый хочет гонять
этот сценарий), какие юнит-тесты прогонять (новая функциональность или баг скорее всего затрагивает только часть приложения, не обязательно
гонять все юнит-тесты, которых может быть сотни).

Для решения этой задачи будет использоваться freestyle job.

### Настройка Jenkins

## Второй кейс

Рассматриваем ситуацию, когда разработчик закончил работу в локальной ветке, убедился, что все собирается корректно, отрефакторил код, прогнал 
юнит-тесты, которые затрагивают его работу и делает push в основную релизную ветку. Как только в релизную ветку (develop или main или release) 
происходит пуш, сразу должен срабатывать триггер, запускающий пайплайн, который будет проверять код по всем фронтам: сборка, прогонка юнит-тестов и авто-тестов, формирование отчета о покрытии, полный фарш.

Для этой цели будем использовать pipeline и сценарии через jenkins-файлы.

Для запуска пайплайна будем использовать Jenkinsfile. Но Jenkinsfile с groovy кодом находится на гитхабе,  так что надо его оттуда вытащить
(как правило, Jenkinsfile находится в том же репозитории, что и сам проект, но в данном случае это не так исплючительно в образовательных целях).

### Настройка Jenkins

### Настройка Sonarcube и отчетов по тестам

Sonarcube поднимается на локальном хосте на порту 9000 (как я понял, это стандартный порт сонара). Для того, чтобы работать с веб-интерфейсом
перейдите по адресу localhost:9000 в браузере. Там вы увидете страницу авторизации. Логин и пароль по умолчанию admin/admin. После авторизации
вам будет предложено создать новый пароль и далее будет доступна работа с сонаром.

Для работы с sonarcube нужно выпустить токен авторизации: Administration -> Security -> Users -> создаем токен

Для работы с sonarcube из Jenkins понадобится расширение Sonarcube Scanner. Установить его можно через Jenkins веб-интерфейс: Настройки Jenkins -> Pluggins -> Ищем и устанавливаем нужное расширение.
Далее настраиваем взаимодействие Jenkins с sonarcube (как минимум jenkins должен знать, где находится sonarcube и как к нему подключаться): Настроить Jenkins -> System -> SonarQube servers. Вводим url сонара и добавляем токен авторизации, который завели на sonar.

### Настройка github hook, ngrock